#define _CRT_SECURE_NO_WARNINGS


#include <stdio.h>
union Un
{
	int i;
	// int类型 占用 4 个字节，所以 联合大小 至少是 4 个字节
	// 
	// 对齐数 为 联合体成员(4字节) 与 默认对齐数(8字节) 之中的 较小值，
	// 即为 4

	char arr[5]; 
	// 该数组 有 5 个 char类型 的 元素，所以占用 5 个字节，即 联合大小 至少是 5 个字节，
	// 
	// 对齐数 为 联合体成员(1字节) 与 默认对齐数(8字节) 之中的 较小值，
	// 即为 1
	// 
	// 数组中元素的类型 占多少个字节，作为 该数组(联合体成员) 的 对齐数，
	// 此题为 char类型 的 数组，而 char类型 占用 1 个字节，所以 对齐数 为 1 。

	// 1、联合的大小 至少是 最大成员的大小。
	//    所以 联合的大小 至少是 5 ；
	// 
	// 2、当 最大成员大小 不是 最大对齐数 的 整数倍 的时候，
	//    就要 对齐到 最大对齐数(指 联合成员的对齐数，不包括 默认对齐数) 的 整数倍。
	//    所以 最大对齐数 为 4 ，而 最大成员大小 为 5 ，需要对齐，
	//        对齐之后为 8 。

};

int main()
{
	union Un u;
	printf("%d\n", sizeof(u)); // 打印 8

	return 0;
}



//#include <stdio.h>
//enum Color
//{
//	RED,
//	GREEN,
//	BLUE
//};
//
//int main()
//{
//	enum Color c = RED;
//
//	printf("%d\n", sizeof(c)); // 打印 4
//	// 我们知道 枚举常量 的值 都是 (int类型)整型，
//	// 而 enum Color c = RED; 相当于给 c 赋上这个 (int类型)整型值，
//	// 所以 c 的类型 也应该是 (int类型)整型，
//	// 即 4 个字节。
//
//	printf("%d\n", sizeof(enum Color)); // 打印 4
//	// 从 enum Color c = RED; 可知 RED 为 (int类型)整型，
//	// 所以 能接收这个类型的 c 的类型，即 enum Color(枚举类型) 也应该为 (int类型)整型 。
//	// 
//	// 且另一个方面 枚举类型 里的 枚举常量 都是 (int类型)整型 ，
//	// 所以就规定 枚举类型 为 4 个字节。
//	// (就像规定 int类型 为 4 个字节一样)
//
//	return 0;
//}

//enum
//{
//	A,
//	B,
//	C
//};
//
//int main()
//{
//
//	return 0;
//}

//#include <stdio.h>
//int check_sys()
//{
//	union Un
//	{
//		int i;
//		char c;
//	}u; // 这里的 u 表示 创建一个 全局联合体 ，其 联合体变量名 为 u 。
//
//	u.i = 1;
//	// i 为 int类型 ，为 4 个字节，即 32 个比特位，在 内存中 需要 8 位 十六进制位 表示。
//	// 
//	// 若按 小端模式存储 ，则在 内存中 为
//	// ...(低地址)... 01 00 00 00 ...(高地址)...
//	// 
//	// 若按 大端模式存储 ，则在 内存中 为
//	// ...(低地址)... 00 00 00 01 ...(高地址)...
//
//	return u.c;
//	// c 为 char类型 ，为 1 个字节，即 8 个比特位，在 内存中 需要 2 位 十六进制位 表示，
//	// 即 访问内存的大小 为 1 个字节，即 8 个比特位，在 内存中 为 2 位 十六进制位 。
//	// 
//	// 若按 小端模式存储 ，则在 内存中 为
//	// ...(低地址)... 01 00 00 00 ...(高地址)...
//	// 则 u.c 为 01(十六进制) ，即为 1(十进制) 
//	// 
//	// 若按 大端模式存储 ，则在 内存中 为
//	// ...(低地址)... 00 00 00 01 ...(高地址)...
//	// 则 u.c 为 00(十六进制) ，即为 0(十进制) 
//
//}
//
//int main()
//{
//	int ret = check_sys();
//	// check_sys() 返回 1 表示 小端字节序存储模式
//	//             返回 0 表示 大端字节序存储模式
//
//	if (1 == ret)
//	{
//		printf("小端字节序存储模式\n");
//	}
//	else
//	{
//		printf("大端字节序存储模式\n");
//	}
//	// VS编译器 打印 小端字节序存储模式
//
//	return 0;
//}


//#include <stdio.h>
//union Un
//{
//	char c;
//	int i;
//};
//
//int main()
//{
//	union Un u; 
//
//	u.i = 0x11223344;
//
//	u.c = 0x55;
//
//	printf("%x\n", u.i); // 打印 11223355
//
//	return 0;
//}



//#define RED 0
//#define GREEN 1
//#define BLUE 2
//
//int main()
//{
//	int color = RED;
//
//}

//#include <stdio.h>
//enum Color
//{
//	RED = 1,
//
//	GREEN = 2,
//
//	BLUE = 3
//
//};
//
//int main()
//{
//	// enum Color c1 = RED;
//	// 我们知道 RED 的值 为 1 ，那我直接
//	enum Color c1 = 1;
//	// 这样的写法是不对的，
//	// 但 能编译过去 且无报错，是因为 C语言 的检测不严格，如果换成 C++ 就 直接无法编译，
//	//
//	// 因为 c1 的类型是 enum Color类型 ，而 1 是 int类型 
//
//	return 0;
//}






//#include <stdio.h>
//enum Color
//{
//	RED,
//	GREEN,
//	BLUE
//
//};
//
//int main()
//{
//	printf("%d %d %d\n", RED, GREEN, BLUE); // 打印 0 1 2
//
//	return 0;
//}


//#include <stdio.h>
//enum Color
//{
//	// 枚举常量 赋 特定值。(默认从 0 开始，一次递增 1 )
//	RED = 1,
//	GREEN = 4,
//	BLUE = 7
//
//};
//
//int main()
//{
//	printf("%d %d %d\n", RED, GREEN, BLUE); // 打印 1 4 7
//
//	return 0;
//}


//enum Color // 颜色
//{
//	// 枚举常量 用 逗号 隔开
//	RED,
//	GREEN,
//	BLUE
//
//}; // 最后不要忘记 分号
//
//int main()
//{
//
//	return 0;
//}


//struct S
//{
//	char a : 3;
//	char b : 4;
//	char c : 5;
//	char d : 4;
//};
//
//int main()
//{
//	struct S s = { 0 };
//
//	// 给每一个 位段成员 赋值
//
//	s.a = 10; // 二进制为 1010
//
//	s.b = 12; // 二进制为 1100
//
//	s.c = 3; // 二进制为 11
//
//	s.d = 4; // 二进制为 100
//
//	return 0;
//}



//struct S
//{
//	int a : 33;
//	// 在 VS编译器 中，
//	// int类型 占 4 个字节，即 32 个比特位，
//	// 而 位段成员的大小，不能超出 该类型所占的比特位 的数量，
//	// 否则不能编译。
//};
//
//int main()
//{
//
//	return 0;
//}


//#include <stdio.h>
//
//// 位段
//// 这里的 位 指 二进制位
//struct S
//{
//	// 假如我的 a 只有 1、2、3、4 这 4 种情况，
//	// 若 a 直接占用之一 int类型 ，即 4 个字节(type)，即 32 个比特位(bit)，
//	// 能表示 2 的 32 次方种情况，
//	// 而我们只需要表示 4 种情况即可，这导致浪费很多内存。
//	int a : 2;
//	// 所以这里的 int a : 2; 表示：
//	// 开辟一个 int类型 的空间给 a ，但是 a 指占其中的 2 个比特位，
//	// 2 个比特位就足够表示 a 的 4 种情况。
//
//	int b : 5;
//	int c : 10;
//	int d : 30;
//};
//
//int main()
//{
//	struct S s;
//
//	printf("%d\n", sizeof(s)); // 打印 8 (字节)
//
//	return 0;
//}


//struct A
//{
//	int a : 2;
//	int b : 5;
//	int c : 10;
//	int d : 30;
//};
//
//int main()
//{
//
//	return 0;
//}




//#include <stdio.h>
//
//int main()
//{
//	enum S
//	{
//		MALE,
//		FEMALE,
//		SECURTE
//	};
//	printf("%d\n", sizeof(enum S));
//	return 0;
//}

//#include <stdio.h>
//struct S
//{
//	int i;
//	char c;
//};
//
//// 结构体传参
//void Init1(struct S tmp)
//{
//	// 结构体传参 ，此处的 tmp 是 实参s 的一份 临时拷贝，
//	// 所以下面更改的是 临时拷贝 中的内容，
//	// 并没有真正对 实参s 的内容进行更改。
//	tmp.i = 10;
//	tmp.c = 'w';
//}
//
//void Print1(struct S tmp)
//{
//	// 因为 没有 对结构体的内容 进行更改，只是进行打印，
//	// 所以 结构体传参 和 地址传参 都能实现同样的效果，
//	// 
//	// 只是 地址传参 是更优解，
//	// 因为 结构体传参 会产生 一份结构体的临时拷贝，占用更多内存空间
//	// 而 地址传参 不会。
//	printf("%d %c\n", tmp.i, tmp.c);
//}
//
//// 结构体地址传参
//void Init2(struct S* ps)
//{
//	// 地址传参 ，此处的 结构体指针ps 与 实参地址&s 指向同一空间，
//	// 对 ps 指向空间的内容 进行更改，就相当于对 实参地址&s 指向空间的内容 进行更改，
//	// 所以 结构体地址传参 能够在 函数中 对 main()主函数 中的结构体的内容进行更改。
//	ps->i = 10;
//	(*ps).c = 'w';
//}
//
//void Print2(const struct S* ps)
//{
//	// 因为 没有 对结构体的内容 进行更改，只是进行打印，
//	// 所以 结构体传参 和 地址传参 都能实现同样的效果，
//	// 
//	// 只是 地址传参 是更优解，
//	// 因为 结构体传参 会产生 一份结构体的临时拷贝，占用更多内存空间
//	// 而 地址传参 不会。
//	// 
//	// 但是 地址传参 可以真正对 实参s 的内容进行更改，有时 起不到保护内容 的作用，
//	// 如 本函数 只是进行打印，不想 对结构体的内容 进行更改，
//	// 则 可以使用 const修饰 将内容保护起来。
//	printf("%d %c\n", ps->i, (*ps).c);
//}
//
//int main()
//{
//	struct S s = { 0,'c' };
//
//	// 传结构体
//	Init1(s); // 未能 改变 结构体变量s 中的内容
//
//	Print1(s); // 能够打印，打印 0 c
//
//
//	// 传地址
//	Init2(&s); // 能 改变 结构体变量s 中的内容
//
//	Print2(&s); // 能够打印，打印 10 w
//
//	return 0;
//}



//#include <stdio.h>
//#include <stddef.h>
//int main()
//{
//	struct s
//	{
//		char c;
//		int i;
//		double d;
//	};
//
//	printf("%d\n", offsetof(struct s, c)); // 打印 0
//
//	printf("%d\n", offsetof(struct s, i)); // 打印 4
//	
//	printf("%d\n", offsetof(struct s, d)); // 打印 8
//	
//	return 0;
//}

//struct S1
//{
//    char c1; // 占 1 个字节
//    // 空 7 个字节 (对齐数 为 8 ，即 double类型8字节 \ 默认对齐数8字节 中的 较小值)
//    double d;// 占 8 个字节
//    // 总共占 16 个字节
//};
//
//#pragma pack(4) //设置默认对齐数为4
//struct S2
//{
//    char c1; // 占 1 个字节
//    // 空 3 个字节 (对齐数 为 4 ，即 double类型8字节 \ 更改后对齐数4字节 中的 较小值)
//    double d;// 占 8 个字节
//    // 总共占 12 个字节
//};
//#pragma pack() //取消设置的默认对齐数，还原为默认
//
//#pragma pack(1) //设置默认对齐数为1
//struct S3
//{
//    char c1; // 占 1 个字节
//    // 空 0 个字节 (对齐数 为 1 ，即 double类型8字节 \ 更改后对齐数1字节 中的 较小值)
//    double d;// 占 8 个字节
//    // 总共占 9 个字节
//};
//#pragma pack() //取消设置的默认对齐数，还原为默认
//
//#include <stdio.h>
//int main()
//{
//    printf("%d\n", sizeof(struct S1)); // 打印 16
//
//    printf("%d\n", sizeof(struct S2)); // 打印 12
//
//    printf("%d\n", sizeof(struct S3)); // 打印 9
//
//    return 0;
//}



//struct S3
//{
//	int  d;
//	char c;
//	int i;
//};
//
//struct S4
//{
//	char c1;
//	struct S3 s3;
//	double d;
//};
//
//#include <stdio.h>
//int main()
//{
//	printf("%d\n", sizeof(struct S4)); // 打印 32
//
//	return 0;
//}

//struct S3
//{
//	double d;
//	char c;
//	int i;
//};
//
//#include <stdio.h>
//int main()
//{
//	printf("%d\n", sizeof(struct S3)); // 打印 16
//
//	return 0;
//}


//struct S1
//{
//	char c1;
//	int a;
//	char c2;
//};
//
//struct S2
//{
//	char c1;
//	char c2;
//	int a;
//};
//
//#include <stdio.h>
//int main()
//{
//	struct S1 s1 = { 0 }; // 如果不想给 结构体变量 初始化 ，又不想 空着，可以给个 0 ，
//						  // 意思是 结构体变量 中 第一个成员 初始化成 0 ，其他成员 默认初始化成 0 。
//
//	printf("%d\n", sizeof(s1)); // 打印 12
//
//	struct S2 s2; // 空着 也能 编译过去，但是会报 未引用的局部变量 ，就是 未初始化 的意思。
//				  // 编译器认为我们创建了变量就要使用，而我们创建了却生么也没干。
//
//	printf("%d\n", sizeof(s2)); // 打印 8
//
//	return 0;
//}




//typedef struct
//{
//	int date;
//
//	Node* next;
//	// 匿名结构体 重命名 之后 是不能 自引用 的，将无法编译。
//	// 
//	// 因为 运行到这段代码，
//	// 说不清 
//	// 是应该 先 对匿名的结构体类 重命名(都能重命名了，说明结构体成员都确定了，而后面的包含却要在这一步之后) ，
//	//        再用 新结构体类型名 包含 结构体类型的指针 ，
//	// 还是应该 先 包含 匿名结构体的指针(但这里却用 新结构体类型名 来包含) ，
//	//          再对 匿名的结构体类型 重命名 ，
//
//}Node; // 将 匿名结构体类型 重命名 为 Node
//
//int main()
//{
//
//	return 0;
//}

//struct Node
//{
//	int date;
//
//	struct Node1* next;
//	// 结构体 的 自引用 中，
//	// 包含 自己类型的结构体指针 才是 正确的
//	// 
//	// 而且 指针类型 的 大小 是确定的 (4\8 字节)，
//	// 可以使用 sizeof(struct Node) 计算出大小。
//};
//
//int main()
//{
//
//	return 0;
//}

//struct Node1
//{
//	int date;
//	struct Node n;
//	// 但是像这种，两个 结构体类型 之间 相互 反复调用，也是错误的，
//	// 因为 从 C语言 语法上 就不支持，
//	// 使用 该结构体类型 创建变量，该结构体必须 在此之前 声明，
//	// 即 该结构体的声明 在 这条代码(即 使用时) 上方。
//	// 明显 struct Node 结构体声明 在 这条代码(即 使用时) 下方,
//	// 
//	// 而且 函数的声明 可以
//	// 在 使用(指代码) 之前 单独声明一下 ，具体的实现过程 可以放在 使用(指代码) 之后,
//	// 但是 结构体的声明 不可以。
//};
//
//struct Node
//{
//	int date;
//
//	struct Node1 n1;
//
//};
//
//int main()
//{
//
//	return 0;
//}

//struct Node
//{
//	int date;
//
//	struct Node n; // 这种 自引用 的方式 是 错误的。
//	// 代码直接报错不能编译
//	// 
//	// 结构体类型 中 包含一个 自己类型的成员变量是 不行的，
//	// 可以试想一下：
//	// sizeof(struct Node) 的大小是无法计算的，
//	// 其中 int 占 4 个字节，
//	//      struct Node n; 中又有 int 和 struct Node n; 
//	//      ......
//	// 所以计算机是无法编译的。
//
//};
//
//int main()
//{
//
//	return 0;
//}


//typedef struct
//{
//	int a;
//	char c;
//}Stu; // 匿名结构体类型的标签 被重命名为 Stu
//
//int main()
//{
//	Stu s1 = { 0 }; 
//	// 通过 typedef 对 匿名结构体类型的标签 重命名 后，
//	// 也能用 新标签名 创建 匿名结构体类型的变量
//}


//struct 
//{
//	int a;
//	char c;
//}x;// 用这个 匿名结构体类型 创建了 一个结构体变量x
//
//struct 
//{
//	int a;
//	char c;
//}*p;// 用这个 匿名结构体类型 创建了 一个结构体指针p
//
//int main()
//{
//	p = &x;
//	// 虽然 能编译过去，只是报 类型不兼容 的警告，
//	// 但是这是这种写法是完全错误的。
//	// 
//	// 一种结构体类型创建的指针 不能 存放 另一种结构体类型创建的变量的地址，
//	// 就算结构体成员变量都相同 也不行，会报类型不兼容警告。
//	// 
//	// 就算是两个 匿名的结构体类型( 看似都没结构体标签 内存应该指向同一个东西 实则 不是) ，
//	// 编译器 也会把 两个匿名的结构体类型 当成 完全不同 的 两个类型，
//	// 所以上文的写法是非法的。
//
//	return 0;
//}



//// 匿名结构体类型
//struct
//{
// int a;
// char b;
// float c;
//}x, a[20], *p;
//// 没有 结构体标签 ，
//// 只能使用 结构体后面 创建 全局变量 的 方式 创建 结构体变量 。
////
////这里用这个 结构体类型 创建了 一个结构体变量 ，一个结构体变量的数组 ，一个结构体指针
//
//
//int main()
//{
//
//	return 0;
//}