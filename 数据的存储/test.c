#define _CRT_SECURE_NO_WARNINGS

#include <stdio.h>
int main()
{
	int n = 9;
	//以 整型 的形式存入内存
	// 00000000 00000000 00000000 00001001 -> 正数三码相同

	float* pFloat = (float*)&n; //强制类型转换是在转换类型，如果没有精度丢失，值是不会发生变化的。

	printf("n的值为：%d\n", n); 
	//以 整型 的形式存入内存，再以 整型 的形式读取，
	//打印 9

	printf("*pFloat的值为：%f\n", *pFloat);
	//以 整型 的形式存入内存，再以 浮点型 的形式读取，
	// 00000000 00000000 00000000 00001001 -> 内存中的补码
	//以 浮点型 的形式读取，
	// 0   00000000   00000000000000000001001
	// S   E(E全为0)  M(只存二进制小数部分，整数部分的 1 不存)
	// 即  (-1)^0  *  (0.00000000000000000001001)B  *  2^-126  是一个非常小的数，
	// 
	// 而且使用 %f 打印，只打印小数点后六位，所以打印出 0.000000

	*pFloat = 9.0;
	//以 浮点型 的形式存入内存
	// 1001.0 -> 二进制
	// 即  (-1)^0  *  1.001 * 2^3
	// S = 0 ; M = 1.001 ; 真实值 E = 2 ，需要加上一个 中间值 ，
	//                     float类型 中间值 为 127 ，即 存储值 E = 3 + 127 = 130
	// 0 10000010 00100000000000000000000   ->   内存存储形式

	printf("num的值为：%d\n", n);
	//以 浮点型 的形式存入内存，再以 整型 的形式读取，
	// 即 01000001 00010000 00000000 00000000 -> 当作一个 整型的补码 处理
	// 对应 十进制 为 1091567616
	// 打印 1091567616

	printf("*pFloat的值为：%f\n", *pFloat);
	//以 浮点型 的形式存入内存，再以 浮点型 的形式读取，
	//打印 9.000000

	return 0;
}

//#include <stdio.h>
//int main()
//{
//	float f = 5.5;
//	// 5.5   ->   十进制
//	// 101.1   ->   二进制
//	// (-1)^0  *  1.011  *  2^2   ->   表示形式
//	// S = 0 ; M = 1.011 ; 真实值 E = 2 ，需要加上一个 中间值 ， 
//	//                     float类型 中间值 为 127 ，即 存储值 E = 2 + 127 = 129
//	// 0 10000001 01100000000000000000000   ->   内存存储形式
//	// S    E     M(只存二进制小数部分，整数部分的 1 不存)
//	// 
//	//    0100 0000 1011 0000 0000 0000 0000 0000 -> 内存存储形式
//	// 0x  4    0    b    0    0    0    0    0  -> 以十六进制展示
//
//	return 0;
//}

//#include <stdio.h>
//int main()
//{
//    unsigned char i = 0;
//
//    for (i = 0; i <= 255; i++)
//    {
//        printf("hello world\n"); // 死循环 打印 hello world
//    }
//    // i = 0 时，
//    // 00000000 00000000 00000000 00000000 - (正数三码相同)
//    // 00000000 - 截断后存入 char 的 补码(正数三码相同)
//    // 即此时 char类型 中的 值 为 0
//    // 
//    // 如此 i++ 下去，
//    // 
//    // i = 255 时，
//    // 00000000 00000000 00000000 11111111 - (正数三码相同)
//    // 11111111 - 截断后存入 char 的 补码
//    // 因为 char类型 被定义为 unsigned 无符号 ，所以最高位不是 符号位 而是 有效位 ，
//    // 11111111 - 为 8 位 有效位 (正数三码相同)
//    // 即此时 char类型 中的 值 为 255 
//    // 
//    // i = 256 时，
//    // 00000000 00000000 00000001 00000000 - (正数三码相同)
//    // 00000000 - 截断后存入 char 的 补码
//    // 因为 char类型 被定义为 unsigned 无符号 ，所以最高位不是 符号位 而是 有效位 ，
//    // 00000000 - 截断后存入 char 的 补码(正数三码相同)
//    // 即此时 char类型 中的 值 为 0 
//    // 
//    // 所以 无论 i++ 怎么增加， unsigned char 的 值 范围始终只有 0~255 ，
//    // 虽然 i++ 通过 整型提升 后自增，但是 i 始终是 unsigned char ，自增完后要 截断
//    //
//    // 所以 i 始终 <= 255 ，会死循环 打印 hello world
//
//    return 0;
//}


//#include <stdio.h>
//int main()
//{
//    char a[1000]; 
//	
//    int i;
//
//    for (i = 0; i < 1000; i++)
//    {
//        a[i] = -1 - i;
//    }
//    // 因为 i 是 int整型 ，但需要放进 char类型 中，所以会发生 截断
//    // 
//    // 当 i = 0 ，即 -1 - 0 时，为 -1 ，
//    // 10000000 00000000 00000000 00000001 -> -1的原码
//    // 11111111 11111111 11111111 11111110 -> -1的反码
//	// 11111111 11111111 11111111 11111111 -> -1的补码
//    // 11111111 -> 截断后存入 char 的 补码
//    // 11111110 -> 截断后存入 char 的 反码
//    // 10000001 -> 截断后存入 char 的 原码
//    // 即 -1
//    // 
//    // 当 i = 1 ，即 -1 - 1 时，为 -2 ，
//    // 10000000 00000000 00000000 00000010 -> -2的原码
//    // 11111111 11111111 11111111 11111101 -> -2的反码
//	// 11111111 11111111 11111111 11111110 -> -2的补码
//    // 11111110 -> 截断后存入 char 的 补码
//    // 11111101 -> 截断后存入 char 的 反码
//    // 10000010 -> 截断后存入 char 的 原码
//    // 即 -2
//    // 
//    // 如此一直减下去，
//    // 
//    // 当 i = 126 ，即 -1 - 126 时，为 -127 ，
//    // 10000000 00000000 00000000 01111111 -> -127的原码
//    // 11111111 11111111 11111111 10000000 -> -127的反码
//	// 11111111 11111111 11111111 10000001 -> -127的补码
//    // 10000001 -> 截断后存入 char 的 补码
//    // 10000000 -> 截断后存入 char 的 反码
//    // 11111111 -> 截断后存入 char 的 原码
//    // 即 -127
//    // 
//    // 当 i = 127 ，即 -1 - 127 时，为 -128 ，
//    // 10000000 00000000 00000000 10000000 -> -128的原码
//    // 11111111 11111111 11111111 01111111 -> -128的反码
//	// 11111111 11111111 11111111 10000000 -> -128的补码
//    // 1 10000000 -> 截断后存入 char 的 补码
//    // 1 01111111 -> 截断后存入 char 的 反码
//    // 1 10000000 -> 截断后存入 char 的 原码
//    // (这个数很特殊，在 char类型 中，遇到 补码 为 10000000 时 编译器会默认为 -128 )
//    // 即 -128
//    // 
//    // 当 i = 128 ，即 -1 - 128 时，为 -129 ，
//    // 10000000 00000000 00000000 10000001 -> -129的原码
//    // 11111111 11111111 11111111 01111110 -> -129的反码
//	// 11111111 11111111 11111111 01111111 -> -129的补码
//    // 01111111 -> 截断后存入 char 的 补码(正数三码相同)
//    // 即 127
//    // 
//    // 当 i = 129 ，即 -1 - 129 时，为 -130 ，
//    // 10000000 00000000 00000000 10000010 -> -130的原码
//    // 11111111 11111111 11111111 01111101 -> -130的反码
//	// 11111111 11111111 11111111 01111110 -> -130的补码
//    // 01111110 -> 截断后存入 char 的 补码(正数三码相同)
//    // 即 126
//    //
//    // 再如此一直减下去，
//    // 
//    // 当 i = 254 ，即 -1 - 254 时，为 -255 ，
//    // 10000000 00000000 00000000 11111111 -> -255的原码
//    // 11111111 11111111 11111111 00000000 -> -255的反码
//	// 11111111 11111111 11111111 00000001 -> -255的补码
//    // 00000001 -> 截断后存入 char 的 补码(正数三码相同)
//    // 即 1
//    // 
//    // 当 i = 255 ，即 -1 - 255 时，为 -256 ，
//    // 10000000 00000000 00000001 00000000 -> -256的原码
//    // 11111111 11111111 11111110 11111111 -> -256的反码
//	// 11111111 11111111 11111111 00000000 -> -256的补码
//    // 00000000 -> 截断后存入 char 的 补码(正数三码相同)
//    // 即 0
//    // 
//    // 当 i = 256 ，即 -1 - 256 时，为 -257 ，
//    // 10000000 00000000 00000001 00000001 -> -257的原码
//    // 11111111 11111111 11111110 11111110 -> -257的反码
//	// 11111111 11111111 11111110 11111111 -> -257的补码
//    // 11111111 -> 截断后存入 char 的 补码
//    // 11111110 -> 截断后存入 char 的 反码
//    // 10000001 -> 截断后存入 char 的 原码
//    // 即 -1
//    // 
//    // 在 for循环 的 i 还没到超出 小于1000 的 判定条件 时，
//    // 存入 a数组中 的 数 ，在 -1，-2 ，...，-128，127，126，...，1，0，又回到 -1 ，如此循环
//    // 也可以理解为 char类型 表示的 值 只有 -127~128 之间
//
//    printf("%d", strlen(a));
//    // strlen() 遇到 '\0'字符串结束标志(即0) 时停止，计算 '\0'字符串结束标志(即0) 之前有多少个字符
//    // a数组 存放了
//    // -1，-2 ，...，-128，127，126，...，1，0，又回到 -1 ，如此循环
//    //     (128个负数)        (127个正数)   (↑遇上这个 0 就已经结束)
//    // 
//    //打印 255
//
//    return 0;
//}


//#include <stdio.h>
//int main()
//{
//	unsigned int i;
//
//	for (i = 9; i >= 0; i--)
//	{
//		printf("%u\n", i);
//	}
//	// i = 9 时，
//	// 00000000 00000000 00000000 00001001 -> 9的补码(正数三码相同)
//	// 
//	// i-- ,直到 i = 0 时，
//	// 00000000 00000000 00000000 00000000 -> 0的补码(正数三码相同)
//	// 
//	// 再次 i-- 后 i = -1 ，
//	// 10000000 00000000 00000000 00000001 -> -1的原码
//	// 11111111 11111111 11111111 11111110 -> -1的反码
//	// 11111111 11111111 11111111 11111111 -> -1的补码
//	// 
//	// 因为 i 是 无符号整数 ，所以 -1 的 补码 中 符号位 变成 有效位 ，即
//	// 11111111 11111111 11111111 11111111 - 所有位都是 有效位 ，是一个超级大的数字，为4294967295
//	// 
//	// 所以 先打印 9 8 7 6 5 4 3 2 1 0 ，
//	// 然后打印 4294967295 ，接着每次 减1 ，直至 0 ，然后再打印 4294967295 ，如此循环
//
//	return 0;
//}

//#include <stdio.h>
//int main()
//{
//	int i = -20;
//	// 10000000 00000000 00000000 00010100 - 原码
//	// 11111111 11111111 11111111 11101011 - 反码
//	// 11111111 11111111 11111111 11101100 - 补码
//
//	unsigned  int  j = 10;
//	// 00000000 00000000 00000000 00001010 - 补码(正数三码相同)
//
//	printf("%d\n", i + j);
//	// i + j 
//	// 11111111 11111111 11111111 11101100 -> -20的补码
//	// 00000000 00000000 00000000 00001010 ->  10的补码
//	// 11111111 11111111 11111111 11110110 -> i + j 的补码
//	// printf() 打印使用原码
//	// 11111111 11111111 11111111 11110101 -> i + j 的反码
//	// 10000000 00000000 00000000 00001010 -> i + j 的原码
//	// 即 打印 -10
//	
//	return 0;
//}
////按照补码的形式进行运算，最后格式化成为有符号整数

//#include <stdio.h>
//int main()
//{
//    char a = 128; //相当于 127 + 1
//                  //00000000 00000000 00000000 01111111 - 127的补码(正数三码相同)
//                  // 加 1 ，即
//                  //00000000 00000000 00000000 10000000 - 128的补码
//                  // 
//                  //整型 存进 char类型 中发生 截断
//                  // 10000000 - 截断后的补码
//                  // 
//                  //跟上面 -128 截断后的补码一样，
//                  // char a = -128;
//                  // 10000000 00000000 00000000 10000000 -> -128的原码
//                  // 11111111 11111111 11111111 01111111 -> -128的反码
//                  // 11111111 11111111 11111111 10000000 -> -128的补码
//                  // 10000000 -> -128截断后的补码
//                  //
//                  //所以这里 char a = 128; 相当于 char a = -128;
//
//    printf("%u\n", a); //打印 4294967168
//
//    return 0;
//}

//int main()
//{
//    char a = -128;
//    // 10000000 00000000 00000000 10000000 - 原码
//    // 11111111 11111111 11111111 01111111 - 反码
//    // 11111111 11111111 11111111 10000000 - 补码
//    // 
//    //整型 存进 char类型 中发生 截断
//    // 10000000 - 截断后的补码
//    // 
//    //因为 printf("%u\n", a);  打印 十进制 的 无符号 数字 ,
//    //需要对 截断后的补码 进行 整型提升 ，
//    // 11111111 11111111 11111111 10000000 - 整型提升后的补码
//    //
//    //又因为打印 无符号的数字 ，而 无符号数字 三码相同 ，
//    //所以打印 11111111 11111111 11111111 10000000 对应的 十进制数 ，
//    //即 4294967168
//
//    printf("%u\n", a); //打印 4294967168
//    // %d - 打印 十进制 的 有符号 数字
//    // %u - 打印 十进制 的 无符号 数字
//
//    return 0;
//}


//#include <stdio.h>
//int main()
//{
//	char a = -1;
//	// 10000000 00000000 00000000 00000001   -   -1的原码
//	// 11111111 11111111 11111111 11111110   -   -1的反码
//	// 11111111 11111111 11111111 11111111   -   -1的补码
//	// 
//	// 而 char 只能放下 1个字节 即 8个比特位 的长度 ，
//	// 11111111   -   截断后的补码
//	// 
//	// 用 %d 打印需要使用 整型 ，所以要对截断后的补码进行 整型提升 ，
//	// 而 整型提升 是按照 变量的数据类型的 符号位 来提升的 ，
//	// 
//	// 此处为 有符号数 ，且为 负数 ，负数符号位 为 1 ，整型提升全为 1 ，
//	// 11111111 11111111 11111111 11111111   -   整型提升后的补码
//	// 
//	// printf() 使用原码打印 ，负数的三码需要计算 ，即
//	// 11111111 11111111 11111111 11111110   -   整型提升后的反码
//	// 10000000 00000000 00000000 00000001   -   整型提升后的原码
//	//即打印 -1
//	
//	signed char b = -1;
//	// signed char 和 char 是同一样东西，只不过一般省略 signed
//	// 
//	// 11111111   -   截断后的补码
//	//
//	// 用 %d 打印需要使用 整型 ，所以要对截断后的补码进行 整型提升 ，
//	// 而 整型提升 是按照 变量的数据类型的 符号位 来提升的 ，
//	// 
//	// 此处为 有符号数 ，且为 负数 ，负数符号位 为 1 ，整型提升全为 1 ，
//	// 11111111 11111111 11111111 11111111   -   整型提升后的补码
//	//
//	// printf() 使用原码打印 ，负数的三码需要计算 ，即
//	// 11111111 11111111 11111111 11111110   -   整型提升后的反码
//	// 10000000 00000000 00000000 00000001   -   整型提升后的原码
//	//即打印 -1
//	
//	unsigned char c = -1;
//	//无论是 有符号 还是 无符号 ，内存中 补码 的那个 二进制数 都是一样，
//	//只不过 有符号 则 最高位 为 符号位 ， 其余位 为 有效位 ，
//	//       无符号 则 都为 有效位
//	// 
//	// 11111111   -   截断后的补码
//	// 
//	// 用 %d 打印需要使用 整型 ，所以要对截断后的补码进行 整型提升 ，
//	// 而 整型提升 是按照 变量的数据类型的 符号位 来提升的 ，
//	// 
//	// 此处为 无符号数 ，即为 正数 ，负数符号位 为 0  ，整型提升全为 0 ，
//	// 00000000 00000000 00000000 11111111   -   整型提升后的补码
//	//
//	// printf() 使用原码打印 ，正数三码相同 ，即
//	// 00000000 00000000 00000000 11111111   -   整型提升后的原码
//	//即打印 255
//
//	printf("a = %d , b = %d , c = %d\n", a, b, c);
//	//打印 a = -1 , b = -1 , c = 255
//
//	return 0;
//}

////设计一个程序判断当前机器的字节序(大端、小端字节序存储模式的判断)
//#include <stdio.h>
////再优化
//int check_sys()
//{
//	int a = 1;
//
//	return *(char*)&a; // char* pa = (char*)&a;
//                       // return *pa;
//	                   //其中 指针变量pa 只是作为一个过渡的桥梁，
//	                   // 可以直接 return *(char*)&a; 省去中间环节
//}
//
//////优化
////int check_sys()
////{
////	int a = 1;
////
////	char* pa = (char*)&a;
////
////	return *pa; //既然 *pa 的值为 1 或 0 ，
////	            //我们可以直接返回，而不需要判断
////}
//
////int check_sys()
////{
////	int a = 1;
////	//    0000 0000 0000 0000 0000 0000 0000 0001   -   正数三码相同
////	// 0x  0    0    0    0    0    0    0    1     -   以十六进制表示
////
////	char* pa = (char*)&a; // 因为 a 是 int类型 ，存放 &a 需要 int* 即 4个字节 的长度，
////	                      // 而 char* 只能放下 1个字节的长度 ，
////						  // 所以需要 (char*) 强制类型转换 ，不然会提示错误
////	//
////	//指针类型的意义
////	//1、 指针类型 决定了 指针解引用操作 时 能访问 几个字节
////	//   char* p 时 *p 能访问 1个字节
////	//    int* p 时 *p 能访问 4个字节
////	// 
////	//2、 指针类型 决定了 指针+-整数 时 加上或减去 几个字节
////	//   char* p 时 p+1 跳过 1个字符 ，即 1个字节
////	//    int* p 时 p+1 跳过 1个整型 ，即 4个字节
////	//
////	// 因为 a=1 ，在内存中展示为 0x 00 00 00 01 ，
////	// 而 char* 指针类型 取地址和解引用操作 都只能访问 1个字节 ，
////	// 所以 若为 大端存储方式 *pa 应该为 0x00 ，即为 0 ；
////	//      若为 小端存储方式 *pa 应该为 0x01 , 即为 1 。
////
////	if (*pa == 1)
////		return 1;
////	else
////		return 0;
////}
//
//int main()
//{
//	int ret = check_sys(); // check_sys() 返回 1 则为 小端字节序存储模式 ，
//						   //             返回 0 则为 大端字节序存储模式 。
//
//	if (ret == 1)
//		printf("小端字节序存储模式\n");
//	else
//		printf("大端字节序存储模式\n");
//
//	return 0;
//}


//#include <stdio.h>
//int main()
//{
//	int a = 0x11223344;
//	char* pa = &a;
//
//	//("%c\n", *pa);
//
//	if (*pa == 'D')
//	{
//		printf("小端\n");
//	}
//	else
//	{
//		printf("大端\n");
//	}
//	return 0;
//}

//#include <stdio.h>
//int main()
//{
//	int a = 20;
//	//    0000 0000  0000 0000  0000 0000  0001 0100   -   原码
//	//    0000 0000  0000 0000  0000 0000  0001 0100   -   反码
//	//    0000 0000  0000 0000  0000 0000  0001 0100   -   补码
//	//内存中展示的是 十六进制 ，而 4位二进制数 表示 1位十六进制数
//	//0x   0    0     0    0     0    0     1    4     -   补码(十六进制)
//
//	int b = -10;
//	//    1000 0000  0000 0000  0000 0000  0000 1010   -   原码
//	//    1111 1111  1111 1111  1111 1111  1111 0101   -   反码
//	//    1111 1111  1111 1111  1111 1111  1111 0110   -   补码
//	//内存中展示的是 十六进制 ，而 4位二进制数 表示 1位十六进制数
//	//0x   f    f     f    f     f    f     f    6     -   补码(十六进制)
//
//	return 0;
//}

//#include <stdio.h>
//void test(void)
//{
//	printf("hehe\n");
//}
//
//int main()
//{
//	test(100);
//	return 0;
//}

//#include <stdio.h>
//int main()
//{
//	int a = 20;
//	int b = -10;
//	int* p = &a;
//	return 0;
//}